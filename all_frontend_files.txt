1) .\eslint.config.js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


2) .\index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


3) .\package.json
{
  "name": "tcrm-mobile",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@ant-design/icons": "^6.0.0",
    "@hookform/resolvers": "^5.2.1",
    "@tailwindcss/vite": "^4.1.11",
    "@tanstack/react-query": "^5.84.2",
    "antd": "^5.27.0",
    "axios": "^1.11.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-hook-form": "^7.62.0",
    "react-input-mask": "^2.0.4",
    "react-phone-number-input": "^3.4.12",
    "react-router-dom": "^7.8.0",
    "tailwindcss": "^4.1.11",
    "zod": "^4.0.17",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.32.0",
    "@types/node": "^24.2.1",
    "@types/react": "^19.1.9",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^4.7.0",
    "eslint": "^9.32.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.39.0",
    "vite": "^7.1.0"
  }
}


4) .\tsconfig.app.json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    "baseUrl": ".",
    "paths": { "@/*": ["src/*"] },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


5) .\tsconfig.json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


6) .\tsconfig.node.json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "types": ["node"],
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


7) .\vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import path from 'node:path'

export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      '@pages': path.resolve(process.cwd(), 'src/pages'),
      '@': path.resolve(process.cwd(), 'src')
    }
  }
})



8) .\src\index.css
@import "tailwindcss";

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;

}
html, body{
  max-width: 100%;
  height: fit-content;
  min-height: 100vh;
}
#root {
  max-width: 420px;
  height: 100dvh;
}

@media (max-width: 410px) {
  #root {
    max-width: 100vw;
  }
}


@media (min-width: 411px) and (max-width: 709px) {
  #root {
    max-width: 100vw;
  }
}

@media (min-width: 710px) {
  body{
    display: flex;
    justify-content: center;
    align-items: center;
  }
}

/* фон приложения — мягкий светлый градиент */
body {
  background:
    radial-gradient(1200px 600px at 50% -10%, rgba(59,130,246,0.08), transparent),
    linear-gradient(180deg, #f8fafc 0%, #eef2f7 100%);
}

/* общий контейнер — мобайл-центрирование и отступы */
.app-container {
  max-width: 900px;
  margin: 0 auto;
  padding: 16px;
}

/* «карточная» секция */
.section-card {
  background: #fff;
  border-radius: 16px;
  box-shadow: 0 10px 30px rgba(2, 6, 23, 0.06);
  padding: 16px;
  margin-bottom: 12px;
}

/* нижняя панель действий (стекло) */
.action-bar {
  position: sticky;
  bottom: 0;
  left: 0; right: 0;
  border-top: 1px solid rgba(0,0,0,0.06);
  background: rgba(255,255,255,0.9);
  backdrop-filter: blur(10px);
  padding: 12px 16px calc(env(safe-area-inset-bottom,0px) + 12px);
  box-shadow: 0 -8px 18px rgba(15, 23, 42, 0.06);
}

.action-bar__inner {
  max-width: 900px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

/* подсуммирование */
.summary-card {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 6px 12px;
}
.summary-card .label { color: #64748b; } /* slate-500 */
.summary-card .value { font-weight: 600; }

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}

a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}

button:hover {
  border-color: #646cff;
}

button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }

  a:hover {
    color: #747bff;
  }

  button {
    background-color: #f9f9f9;
  }
}

/* Текст выбранного значения (в триггере) — обрезаем с троеточием */
.nqs-select .ant-select-selection-item {
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Сам селектор — не вылезаем и не растягиваем родителя */
.nqs-select .ant-select-selector {
  width: 100%;
  max-width: 100%;
  overflow: hidden;          /* важно */
}

/* В режиме поиска (когда есть инпут внутрь селектора) — даём ужаться */
.nqs-select .ant-select-selection-search-input {
  min-width: 0;
}

/* Контент опций в дропдауне — тоже режем и не даём вылезать */
.nqs-select .ant-select-item-option-content {
  display: inline-block;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* На узких экранах — подстраховка, чтобы выпадашка не шире вьюпорта */
.ant-select-dropdown {
  max-width: 100vw;
}

/* Толще рамки в ошибках (AntD) */
.ant-select-status-error .ant-select-selector,
.ant-input-number-status-error,
.ant-input-status-error,
.ant-picker-status-error .ant-picker,
.ant-cascader-status-error .ant-cascader,
.ant-tree-select-status-error .ant-select-selector {
  border-width: 2px !important;
}

9) .\src\main.tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
import TokenScreen from '@/screens/TokenScreen'
import SaleScreen from '@/screens/SaleScreen'
import { SaleGuard } from './components/SaleGuard'
import { AppThemeProvider } from './theme'
import 'antd/dist/reset.css'
import './index.css'

const qc = new QueryClient()

const router = createBrowserRouter([
  { path: '/', element: <TokenScreen /> },
  { path: '/sale', element: <SaleGuard><SaleScreen/></SaleGuard> },
])

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <AppThemeProvider>
      <QueryClientProvider client={qc}>
        <RouterProvider router={router} />
      </QueryClientProvider>
    </AppThemeProvider>
  </StrictMode>,
)

10) .\src\theme.tsx
import { ConfigProvider, App as AntApp, theme } from 'antd'
import ruRU from 'antd/locale/ru_RU'
import React from 'react'

export function AppThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <ConfigProvider
      locale={ruRU}
      theme={{
        algorithm: theme.defaultAlgorithm,
        token: {
          colorPrimary: '#3b82f6',  // tailwind sky-500
          colorInfo: '#3b82f6',
          colorSuccess: '#22c55e',
          colorWarning: '#f59e0b',
          colorError: '#ef4444',

          borderRadius: 12,
          fontSize: 14,
          controlHeightLG: 42,

          colorBgLayout: '#f7f9fb',
          colorBorder: 'rgba(0,0,0,0.12)',
        },
        components: {
          Button: { borderRadius: 12, controlHeight: 40, controlHeightLG: 44 },
          Input: { borderRadius: 10, controlHeight: 40 },
          Select: { borderRadius: 10, controlHeight: 40 },
          Card: { borderRadiusLG: 16 },
          Modal: { borderRadiusLG: 16 },
          Tag: { borderRadiusSM: 10 },
        },
      }}
    >
      <AntApp>{children}</AntApp>
    </ConfigProvider>
  )
}


11) .\src\vite-env.d.ts
/// <reference types="vite/client" />


12) .\src\api\client.ts
// api/client.ts
import axios from 'axios';

export const api = axios.create({ baseURL: 'https://app.tablecrm.com' });

api.interceptors.request.use(cfg => {
  const token = localStorage.getItem('tcrm_token');
  if (token) {
    cfg.params = { ...(cfg.params || {}), token };
  }
  return cfg;
});

13) .\src\api\clients.ts
import { api } from '@/api/client'

export interface Client {
  id: number
  name: string
  phone?: string
}

export async function fetchClients(opts?: { phone?: string; limit?: number }) {
  const { phone, limit = 50 } = opts ?? {}
  const params = new URLSearchParams()
  params.set('limit', String(limit))
  if (phone?.trim()) params.set('phone', phone.trim())

  const { data } = await api.get<{ result: Client[]; count: number }>(
    '/api/v1/contragents/',
    { params }
  )
  return data?.result ?? []
}


14) .\src\api\products.ts
// // api/products.ts
// import { api } from '@/api/client'

// export type CategoryNode = {
//     key: number
//     name: string
//     parent: number | null
//     children?: CategoryNode[]
// }

// export type NomenclatureItem = {
//     id: number
//     name: string
//     unit: number
//     unit_name?: string
//     barcodes?: string[]
//     balances?: { warehouse_name: string; current_amount: number }[]
//     // ...другое из ответа — по желанию
// }

// export async function fetchCategoriesTree() {
//     const { data } = await api.get<{ result: CategoryNode[] }>('/api/v1/categories_tree/')
//     return data.result
// }

// // вернуть «плоский» список детей для конкретного узла
// export function getLevel(tree: CategoryNode[], parent: number | null) {
//     if (parent === null) return tree
//     // ищем узел parent и возвращаем его children
//     const stack = [...tree]
//     while (stack.length) {
//         const n = stack.pop()!
//         if (n.key === parent) return n.children ?? []
//         if (n.children?.length) stack.push(...n.children)
//     }
//     return []
// }

// export type ApiListResponse<T> = {
//     result: T[]
//     count: number
// }

// export type FetchNomenclatureOpts = {
//     category?: number
//     name?: string
//     warehouseId?: number
//     limit?: number
//     offset?: number
// }

// export type NomenclatureQuery = {
//     category?: number
//     name?: string
//     with_prices: boolean
//     with_balance: boolean
//     in_warehouse: number
//     limit: number
//     offset: number
// }

// export async function fetchNomenclaturePage(
//     opts: FetchNomenclatureOpts = {},
// ): Promise<{ items: NomenclatureItem[]; total: number }> {
//     const {
//         category,
//         name,
//         warehouseId = 0,
//         limit = 20,
//         offset = 0,
//     } = opts

//     // формируем объект с типом, без any
//     const params = {
//         with_prices: true,
//         with_balance: true,
//         in_warehouse: warehouseId,
//         limit,
//         offset,
//         ...(typeof category === 'number' ? { category } : {}),
//         ...(name && name.trim() ? { name: name.trim() } : {}),
//     } satisfies NomenclatureQuery

//     const { data } = await api.get<ApiListResponse<NomenclatureItem>>(
//         '/api/v1/nomenclature/',
//         { params },
//     )

//     return { items: data.result, total: data.count }
// }

// export function sumBalance(n: NomenclatureItem) {
//     if (!n.balances?.length) return 0
//     return n.balances.reduce((s, b) => s + (Number(b.current_amount) || 0), 0)
// }
// api/products.ts
import { api } from '@/api/client'

export type CategoryNode = {
  key: number
  name: string
  parent: number | null
  children?: CategoryNode[]
}

export type NomenclatureItem = {
  id: number
  name: string
  unit: number
  unit_name?: string
  barcodes?: string[]
  balances?: { warehouse_name: string; current_amount: number }[]
}

export type ApiListResponse<T> = { result: T[]; count: number }

export type FetchNomenclatureOpts = {
  category?: number
  name?: string
  warehouseId?: number
  limit?: number
  offset?: number
}

export type NomenclatureQuery = {
  category?: number
  name?: string
  with_prices: boolean
  with_balance: boolean
  in_warehouse: number
  limit: number
  offset: number
}

// ---- categories: paged facade over tree -----------------------------------

let _treeCache: CategoryNode[] | null = null

async function loadTreeSafe(): Promise<CategoryNode[]> {
  // если уже грузили — отдадим кэш
  if (_treeCache) return _treeCache
  try {
    const { data } = await api.get<{ result: CategoryNode[] }>('/api/v1/categories_tree/')
    _treeCache = data.result ?? []
  } catch {
    _treeCache = []
  }
  return _treeCache
}

// вернуть детей конкретного родителя из дерева (один уровень)
function getLevel(tree: CategoryNode[], parent: number | null): CategoryNode[] {
  if (parent === null) return tree
  const stack = [...tree]
  while (stack.length) {
    const n = stack.pop()!
    if (n.key === parent) return n.children ?? []
    if (n.children?.length) stack.push(...n.children)
  }
  return []
}

/** Пагинированная загрузка категорий по родителю (клиентская пагинация уровня) */
export async function fetchCategoriesPage(opts: {
  parent: number | null
  limit?: number
  offset?: number
}): Promise<{ items: { id: number; name: string }[]; total: number }> {
  const { parent, limit = 20, offset = 0 } = opts
  const tree = await loadTreeSafe()
  const level = getLevel(tree, parent)
  const total = level.length
  const slice = level.slice(offset, offset + limit)
  return {
    items: slice.map(c => ({ id: c.key, name: c.name })),
    total,
  }
}

// ---- nomenclature ----------------------------------------------------------

export async function fetchNomenclaturePage(
  opts: FetchNomenclatureOpts = {},
): Promise<{ items: NomenclatureItem[]; total: number }> {
  const {
    category,
    name,
    warehouseId = 0,
    limit = 20,
    offset = 0,
  } = opts

  const params = {
    with_prices: true,
    with_balance: true,
    in_warehouse: warehouseId,
    limit,
    offset,
    ...(typeof category === 'number' ? { category } : {}),
    ...(name && name.trim() ? { name: name.trim() } : {}),
  } satisfies NomenclatureQuery

  const { data } = await api.get<ApiListResponse<NomenclatureItem>>(
    '/api/v1/nomenclature/',
    { params },
  )

  return { items: data.result, total: data.count }
}

export function sumBalance(n: NomenclatureItem) {
  if (!n.balances?.length) return 0
  return n.balances.reduce((s, b) => s + (Number(b.current_amount) || 0), 0)
}


15) .\src\api\refs.ts
// api/refs.ts
import { useQuery } from '@tanstack/react-query'
import { api } from './client'

type RefApiItem = { id: number; short_name?: string; name?: string }
type RefResp<T> = { result: T[]; count: number }

const hasToken = () => !!localStorage.getItem('tcrm_token')

export const useOrganizations = (name?: string) =>
  useQuery({
    queryKey: ['organizations', name ?? ''],
    enabled: hasToken(),
    queryFn: async () => {
      const { data } = await api.get<RefResp<RefApiItem>>('/api/v1/organizations/', { params: { name } })
      return (data?.result ?? []).map(i => ({ id: i.id, name: i.short_name || i.name || String(i.id) }))
    },
    staleTime: 300_000,
  })

export const useWarehouses = (name?: string) =>
  useQuery({
    queryKey: ['warehouses', name ?? ''],
    enabled: hasToken(),
    queryFn: async () => {
      const { data } = await api.get<RefResp<RefApiItem>>('/api/v1/warehouses/', { params: { name } })
      return (data?.result ?? []).map(i => ({ id: i.id, name: i.short_name || i.name || String(i.id) }))
    },
    staleTime: 300_000,
  })

export const usePayboxes = (name?: string) =>
  useQuery({
    queryKey: ['payboxes', name ?? ''],
    enabled: hasToken(),
    queryFn: async () => {
      const { data } = await api.get<RefResp<RefApiItem>>('/api/v1/payboxes/', { params: { name } })
      return (data?.result ?? []).map(i => ({ id: i.id, name: i.short_name || i.name || String(i.id) }))
    },
    staleTime: 300_000,
  })

export const usePriceTypes = () =>
  useQuery({
    queryKey: ['price_types'],
    enabled: hasToken(),
    queryFn: async () => {
      const { data } = await api.get<RefResp<{ id:number; name:string }>>('/api/v1/price_types/')
      return data?.result ?? []
    },
    staleTime: 300_000,
  })


16) .\src\api\sales.ts
// api/sales.ts
import { api } from './client'
import type { SalePayload } from '@/types/sale'

export type CreatedDoc =
  | { id?: number; number?: string | number }
  | { result?: Array<{ id?: number; number?: string | number }> }

export async function createSale(payload: SalePayload) {
  const { data } = await api.post<CreatedDoc>('/api/v1/docs_sales/', payload, {
    headers: { 'Content-Type': 'application/json' },
  })
  return data
}

export function extractDocLabel(resp: CreatedDoc): string | undefined {
  const first =
    (Array.isArray(resp?.result) && resp.result[0]) ? resp.result[0] : (resp as unknown)
  const num = first?.number ?? first?.id
  return typeof num === 'number' || typeof num === 'string' ? String(num) : undefined
}

17) .\src\components\Cart.tsx
// src/components/Cart.tsx
import { DeleteOutlined } from '@ant-design/icons'
import { Button, InputNumber, Typography, Divider, Space, Card, Row, Col, Tag, Tooltip } from 'antd'
import { useMemo } from 'react'

const { Text } = Typography

type Line = {
  nomenclature: number
  unit: number
  price: number
  quantity: number
  discount?: number
  sum_discounted?: number
  name?: string
}

type LineErr = { price?: string; quantity?: string; discount?: string; sum_discounted?: string }

export default function Cart({
  rows,
  onChange,
  currency = '₽',
  errors,                                  // ← НОВОЕ
}: Readonly<{
  rows: Line[]
  onChange: (rows: Line[]) => void
  currency?: string
  errors?: LineErr[]
}>) {
  const set = (idx: number, patch: Partial<Line>) => {
    const next = rows.slice()
    next[idx] = { ...next[idx], ...patch }
    onChange(next)
  }
  const remove = (idx: number) => {
    const next = rows.slice()
    next.splice(idx, 1)
    onChange(next)
  }

  const lineSum = (r: Line) => {
    const price = Number(r.price) || 0
    const qty = Math.max(1, Number(r.quantity) || 1)
    const disc = Number(r.discount ?? 0) || 0
    const sumDisc = Number(r.sum_discounted ?? 0) || 0
    return price * qty - disc - sumDisc
  }

  const total = useMemo(() => rows.reduce((s, r) => s + lineSum(r), 0), [rows])

  const fmt = (n: number) =>
    new Intl.NumberFormat('ru-RU', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(n)

  return (
    <div className="mt-3">
      {rows.map((r, i) => {
        const err = errors?.[i] ?? {}
        return (
          <Card
            key={`${r.nomenclature}-${i}`}
            size="small"
            className="mb-2"
            styles={{ body: { padding: 12 } }}
            title={
              <div className="flex items-center justify-between gap-2">
                <div className="min-w-0">
                  <Text className="block truncate">{r.name ?? `#${r.nomenclature}`}</Text>
                  <Text type="secondary" className="!text-[12px]">ед.: {r.unit}</Text>
                </div>
                <Button
                  type="text"
                  aria-label="Удалить позицию"
                  onClick={() => remove(i)}
                  icon={<DeleteOutlined className="text-red-500" />}
                />
              </div>
            }
            extra={null}
          >
            <Space direction="vertical" size={8} className="w-full">
              <Row gutter={8} align="middle">
                <Col span={12}>
                  <Text type="secondary" className="block !text-[12px] mb-1">Цена</Text>
                  <Tooltip title={err.price} placement="top" trigger={['hover', 'focus']} color="red">
                    <InputNumber
                      size="large"
                      className="w-full"
                      min={0}
                      step={0.01}
                      value={r.price}
                      onChange={(v) => set(i, { price: Number(v) || 0 })}
                      controls={false}
                      placeholder="0.00"
                      status={err.price ? 'error' : undefined}
                    />
                  </Tooltip>
                </Col>
                <Col span={12}>
                  <Text type="secondary" className="block !text-[12px] mb-1">Скидка</Text>
                  <Tooltip title={err.discount}  placement="top" trigger={['hover', 'focus']} color="red">
                    <InputNumber
                      size="large"
                      className="w-full"
                      min={0}
                      step={0.01}
                      value={r.discount ?? 0}
                      onChange={(v) => set(i, { discount: Number(v) || 0 })}
                      controls={false}
                      placeholder="0.00"
                      status={err.discount ? 'error' : undefined}
                    />
                  </Tooltip>
                </Col>
              </Row>

              <Row gutter={8} align="middle">
                <Col span={12}>
                  <Text type="secondary" className="block !text-[12px] mb-1">Кол-во</Text>
                  <Tooltip title={err.quantity}  placement="top" trigger={['hover', 'focus']} color="red">
                    <InputNumber
                      size="large"
                      className="w-full"
                      min={1}
                      step={1}
                      value={r.quantity}
                      onChange={(v) => set(i, { quantity: Math.max(1, Number(v) || 1) })}
                      controls
                      status={err.quantity ? 'error' : undefined}
                    />
                  </Tooltip>
                </Col>
                <Col span={12} className="flex items-end justify-end">
                  <div className="text-right">
                    <Text type="secondary" className="block !text-[12px]">Итого</Text>
                    <Tag className="!mt-1 !text-base !py-1 !px-2" color="blue">
                      {fmt(lineSum(r))} {currency}
                    </Tag>
                  </div>
                </Col>
              </Row>
            </Space>
          </Card>
        )
      })}

      <Divider className="!my-3" />

      <div className="flex items-center justify-between px-1">
        <Text strong>Итого</Text>
        <Text strong>{fmt(total)} {currency}</Text>
      </div>
    </div>
  )
}


18) .\src\components\CreateClientModal.tsx
// components/CreateClientModal.tsx
import { Modal, Form, Input, DatePicker, message } from 'antd'
import dayjs from 'dayjs'
import { api } from '@/api/client'

export default function CreateClientModal({
  open, onClose, onCreated,
}: Readonly<{
  open: boolean
  onClose: () => void
  onCreated: (c: { id:number; name:string; phone?:string }) => void
}>) {
  const [form] = Form.useForm()

  const handleOk = async () => {
    const v = await form.validateFields()
    const payload = {
      name: v.name,
      phone: v.phone,
      inn: v.inn || null,
      comment: v.comment || null,
      birthday: v.birthday ? dayjs(v.birthday).unix() : null,
    }
    const { data } = await api.post('/api/v1/contragents/', payload)
    message.success('Контрагент создан')
    onCreated({ id: data.id, name: data.name, phone: data.phone })
    onClose()
    form.resetFields()
  }

  return (
    <Modal open={open} title="Редактирование контрагента" onCancel={onClose} onOk={handleOk} okText="Сохранить" destroyOnClose>
      <Form form={form} layout="vertical">
        <Form.Item label="Имя контрагента" name="name" rules={[{ required:true, message:'Укажите имя' }]}>
          <Input />
        </Form.Item>
        <Form.Item label="Номер контрагента" name="phone" rules={[{ required:true, message:'Укажите телефон' }]}>
          <Input inputMode="tel" />
        </Form.Item>
        <Form.Item label="ИНН контрагента" name="inn"><Input /></Form.Item>
        <Form.Item label="Примечание" name="comment"><Input.TextArea rows={3} /></Form.Item>
        <Form.Item label="Дата рождения" name="birthday"><DatePicker format="DD-MM-YYYY" className="w-full" /></Form.Item>
      </Form>
    </Modal>
  )
}


19) .\src\components\CreateNomenclatureModal.tsx
// components/CreateNomenclatureModal.tsx
import { Modal, Form, Input, Radio, Select, message } from 'antd'
import { api } from '@/api/client'

export default function CreateNomenclatureModal({
  open, onClose, onCreated,
}: Readonly<{
  open: boolean
  onClose: () => void
  onCreated: (n: { id:number; name:string; unit:number; unit_name?:string }) => void
}>) {
  const [form] = Form.useForm()
  const handleOk = async () => {
    const v = await form.validateFields()
    const payload = {
      name: v.name,
      type: v.type,
      description_short: v.short || null,
      description_long: v.long || null,
      code: v.code || null,
      unit: v.unit,
      category: v.category || null,
      manufacturer: v.manufacturer || null,
      cashback_type: v.cashback ? 'lcard_cashback' : null,
      cashback_value: v.cashback || null,
    }
    const { data } = await api.post('/api/v1/nomenclature/', payload)
    message.success('Номенклатура создана')
    onCreated({ id: data.id, name: data.name, unit: data.unit, unit_name: data.unit_name })
    onClose()
    form.resetFields()
  }

  return (
    <Modal open={open} title="Добавить номенклатуру" onCancel={onClose} onOk={handleOk} okText="Подтвердить" destroyOnClose>
      <Form form={form} layout="vertical" initialValues={{ type:'product' }}>
        <Form.Item label="Имя" name="name" rules={[{ required:true, message:'Укажите имя' }]}>
          <Input />
        </Form.Item>
        <Form.Item label="Тип" name="type">
          <Radio.Group>
            <Radio.Button value="product">Товар</Radio.Button>
            <Radio.Button value="service">Услуга</Radio.Button>
          </Radio.Group>
        </Form.Item>
        <Form.Item label="Краткое описание" name="short"><Input.TextArea rows={2} /></Form.Item>
        <Form.Item label="Длинное описание" name="long"><Input.TextArea rows={4} /></Form.Item>
        <Form.Item label="Код" name="code"><Input /></Form.Item>
        <Form.Item label="Единица измерения" name="unit" rules={[{ required:true, message:'Выберите единицу' }]}>
          <Select options={[
            { value: 43, label: 'Килограмм' },
            { value: 1, label: 'Штука' },
          ]} />
        </Form.Item>
        <Form.Item label="Категория" name="category"><Select allowClear showSearch /></Form.Item>
        <Form.Item label="Производитель" name="manufacturer"><Input /></Form.Item>
        <Form.Item label="Кешбек" name="cashback"><Input inputMode="decimal" /></Form.Item>
      </Form>
    </Modal>
  )
}


20) .\src\components\NomenclaturePicker.tsx
// components/NomenclaturePicker.tsx
import { useEffect, useMemo, useState } from 'react'
import { Modal, Input, Table, Button, Space, Typography, Empty, Breadcrumb } from 'antd'
import type { ColumnsType } from 'antd/es/table'
import { fetchCategoriesPage, fetchNomenclaturePage, sumBalance, type NomenclatureItem } from '@/api/products'

const { Text } = Typography

type Row =
  | ({ kind: 'category' } & { id:number; name:string })
  | ({ kind: 'product' } & NomenclatureItem)

type View = 'cats' | 'prods' | 'search'

export default function NomenclaturePicker({
  open, onClose, onPick, warehouseId,
}: Readonly<{
  open: boolean
  onClose: () => void
  onPick: (item: NomenclatureItem) => void
  warehouseId?: number
}>) {
  const [currentParent, setCurrentParent] = useState<number|null>(null)
  const [breadcrumbs, setBreadcrumbs] = useState<Array<{id:number|null; name:string}>>([{ id:null, name:'Категории' }])

  const [view, setView] = useState<View>('cats')
  const [currentCategoryForProds, setCurrentCategoryForProds] = useState<number|undefined>(undefined)

  const [rows, setRows] = useState<Row[]>([])
  const [loading, setLoading] = useState(false)
  const [search, setSearch] = useState('')

  const [catsPage, setCatsPage] = useState(1)
  const [catsSize, setCatsSize] = useState(9)
  const [catsTotal, setCatsTotal] = useState(0)

  const [prodsPage, setProdsPage] = useState(1)
  const [prodsSize, setProdsSize] = useState(9)
  const [prodsTotal, setProdsTotal] = useState(0)

  const loadCats = async (parent: number|null, page=catsPage, size=catsSize) => {
    setLoading(true)
    try {
      const { items, total } = await fetchCategoriesPage({ parent, limit:size, offset:(page-1)*size })
      setCatsTotal(total)
      setRows(items.map(c => ({ kind:'category', id:c.id, name:c.name })))
      setView('cats')
    } finally { setLoading(false) }
  }

  const loadProds = async (category?: number, page=prodsPage, size=prodsSize, q?: string) => {
    setLoading(true)
    try {
      const { items, total } = await fetchNomenclaturePage({
        category, name: q?.trim() || undefined, warehouseId, limit:size, offset:(page-1)*size
      })
      setProdsTotal(total)
      setRows(items.map(i => ({ kind:'product', ...i })))
    } finally { setLoading(false) }
  }

  useEffect(() => {
    if (!open) return
    (async () => {
      setCurrentParent(null)
      setBreadcrumbs([{ id:null, name:'Категории' }])
      setCurrentCategoryForProds(undefined)
      setSearch('')
      setCatsPage(1); setProdsPage(1)
      await loadCats(null, 1, catsSize)
    })()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [open, warehouseId])

  const enterCategory = async (cat: {id:number; name:string}) => {
    setCurrentParent(cat.id)
    setBreadcrumbs(prev => [...prev, { id:cat.id, name:cat.name }])
    setCatsPage(1)
    await loadCats(cat.id, 1, catsSize)
  }

  const viewCategoryProds = async (cat: {id:number; name:string}) => {
    setCurrentCategoryForProds(cat.id)
    setProdsPage(1)
    setView('prods')
    await loadProds(cat.id, 1, prodsSize)
  }

  const goToBreadcrumb = async (idx: number) => {
    const crumb = breadcrumbs[idx]
    const newTrail = breadcrumbs.slice(0, idx+1)
    setBreadcrumbs(newTrail)
    setCurrentParent(crumb.id)
    setCatsPage(1)
    setView('cats')
    await loadCats(crumb.id, 1, catsSize)
  }

  const onBackToCatsRoot = async () => {
    await goToBreadcrumb(0)
  }

  const onDoSearch = async (v: string) => {
    const q = v.trim()
    setSearch(v)
    if (q) {
      setView('search')
      setProdsPage(1)
      await loadProds(undefined, 1, prodsSize, q)
    } else {
      setView('cats')
      setProdsPage(1)
      await loadCats(currentParent ?? null, catsPage, catsSize)
    }
  }

  const columns: ColumnsType<Row> = useMemo(() => [
    {
      title: 'Наименование',
      dataIndex: 'name',
      key: 'name',
    //   width: 210,

      render: (_, r) => r.kind === 'category' ? <Text strong>{r.name}</Text> : r.name,
    },
    {
      title: 'Остаток',
      key: 'balance',
      width: 110,
      render: (_, r) => r.kind === 'product' ? (sumBalance(r) ?? 0) : '',
    },
    {
      title: 'Единица',
      key: 'unit',
      width: 110,
      render: (_, r) => r.kind === 'product' ? (r.unit_name ?? r.unit) : '',
    },
    {
      title: 'ШК',
      width: 110,
      key: 'barcode',
      ellipsis: true,
      render: (_, r) => r.kind === 'product' ? (r.barcodes?.join(', ') ?? '') : '',
    },
    {
      title: 'Действие',
      key: 'act',
      width: 135,
      fixed: 'right',
      render: (_, r) => r.kind === 'product' ? (
        <Button size="small" onClick={() => onPick(r)}>Добавить</Button>
      ) : (
        <Space size={8}>
          <Button size="small" onClick={() => enterCategory({ id:r.id, name:r.name })}>Войти</Button>
          <Button size="small" type="link" onClick={() => viewCategoryProds({ id:r.id, name:r.name })}>Товары</Button>
        </Space>
      ),
    },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  ], [onPick])

  const pagination = view === 'cats'
    ? {
        current: catsPage,
        pageSize: catsSize,
        total: catsTotal,
        showSizeChanger: true,
        onChange: async (p: number, ps: number) => {
          setCatsPage(p); setCatsSize(ps)
          await loadCats(currentParent, p, ps)
        },
      }
    : {
        current: prodsPage,
        pageSize: prodsSize,
        total: prodsTotal,
        showSizeChanger: true,
        onChange: async (p: number, ps: number) => {
          setProdsPage(p); setProdsSize(ps)
          await loadProds(view === 'prods' ? currentCategoryForProds : undefined, p, ps, view === 'search' ? search : undefined)
        },
      }

  return (
    <Modal open={open} onCancel={onClose} title="Выбор номенклатуры" footer={null} width={1000} destroyOnHidden style={{ top: '1%' }}>
      <Space direction="vertical" style={{ width: '100%' }}>
        <div className="flex gap-2 items-center flex-wrap">
          <Breadcrumb>
            {breadcrumbs.map((b, i) => (
              <Breadcrumb.Item key={`${b.id ?? 'root'}-${i}`}>
                <a onClick={() => goToBreadcrumb(i)}>{b.name}</a>
              </Breadcrumb.Item>
            ))}
          </Breadcrumb>

          {view !== 'cats' && (
            <Button onClick={onBackToCatsRoot}>К категориям</Button>
          )}

          <Input.Search
            className="flex-1 min-w-[260px]"
            placeholder="Поиск по наименованию / ШК"
            allowClear
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            onSearch={onDoSearch}
          />
        </div>

        {rows.length === 0 && !loading ? (
          <Empty description="Нет данных" />
        ) : (
          <Table<Row>
            size='small'
            rowKey={(r) => (r.kind === 'category' ? `c-${r.id}` : `p-${r.id}`)}
            columns={columns}
            dataSource={rows}
            loading={loading}
            pagination={pagination}
            scroll={{ x: 900 }}
          />
        )}
      </Space>
    </Modal>
  )
}


21) .\src\components\NomenclatureQuickSearch.tsx
// components/NomenclatureQuickSearch.tsx
import { useEffect, useMemo, useState } from 'react'
import { Select, Spin, Typography, Button, Empty } from 'antd'
import type { DefaultOptionType } from 'antd/es/select'
import { fetchNomenclaturePage, sumBalance, type NomenclatureItem } from '@/api/products'

const { Text } = Typography

type NomOption = DefaultOptionType & {
    value: number
    label: string
    _raw: NomenclatureItem
}

export default function NomenclatureQuickSearch({
    label = 'Поиск номенклатуры',
    warehouseId,
    onPick,
    onOpenPicker,
    error,
}: Readonly<{
    label?: string
    warehouseId?: number
    onPick: (item: NomenclatureItem) => void
    onOpenPicker: () => void,
    error?: boolean
}>) {
    const [loading, setLoading] = useState(false)
    const [all, setAll] = useState<NomenclatureItem[]>([])
    const [value, setValue] = useState<number | undefined>()

    useEffect(() => {
        const load = async () => {
            setLoading(true)
            try {
                const { items } = await fetchNomenclaturePage({
                    warehouseId: warehouseId ?? 0,
                    limit: 50,
                    offset: 0,
                })
                setAll(items)
            } finally { setLoading(false) }
        }
        load()
    }, [warehouseId])

    const options: NomOption[] = useMemo(() => {
        return all.map((i): NomOption => {
            const bal = sumBalance(i)
            const unit = i.unit_name ?? i.unit
            return {
                value: i.id,
                label: `${i.name} • Ост: ${bal ?? '—'} • ${unit}`,
                _raw: i,
            }
        })
    }, [all])

    return (
        <div className="mb-3 w-full">
            <div className="flex items-start gap-2 flex-col w-full">
                <div className="flex-1 min-w-0 w-full">
                    <Text className="block !mb-1" type="secondary">{label}</Text>
                    <Select<number, NomOption>
                        className="w-full nqs-select"
                        showSearch
                        allowClear
                        placeholder="Начните вводить наименование/ШК…"
                        value={value}
                        onChange={(v, opt) => {
                            const picked = Array.isArray(opt) ? undefined : opt
                            setValue(typeof v === 'number' ? v : undefined)
                            if (picked?._raw) onPick(picked._raw)
                        }}
                        options={options}
                        optionFilterProp="label"
                        filterOption={(input, option) =>
                            (option?.label ?? '').toLowerCase().includes(input.toLowerCase())
                        }
                        loading={loading}
                        notFoundContent={
                            loading ? <Spin size="small" /> : (
                                <div className="p-3">
                                    <Empty description="Ничего не найдено" image={Empty.PRESENTED_IMAGE_SIMPLE} />
                                </div>
                            )
                        }
                        popupMatchSelectWidth
                        styles={{
                            popup: {
                                root: {
                                    maxWidth: '100vw'
                                }
                            }
                        }}
                        virtual
                        status={error ? 'error' : undefined}
                        aria-invalid={!!error}
                    />

                </div>

                <Button type="default" onClick={onOpenPicker}>
                    Выбрать
                </Button>
            </div>
        </div>
    )
}


22) .\src\components\PhoneSearch.tsx
// components/PhoneSearch.tsx
import { useEffect, useState } from 'react'
import { Select, Spin, Typography, Empty } from 'antd'
import { fetchClients, type Client } from '@/api/clients'

const { Text } = Typography

export default function PhoneSearch({
  label = 'Контрагент',
  value, onChange, refreshKey, error,
}: Readonly<{
  label?: string
  value?: number
  onChange: (id: number | undefined) => void
  refreshKey?: number
  error?: string
}>) {
  const [options, setOptions] = useState<{ value: number; label: string }[]>([])
  const [loading, setLoading] = useState(false)

  const load = async () => {
    setLoading(true)
    try {
      const data: Client[] = await fetchClients({ limit: 300 })
      setOptions(data.map(c => ({ value: c.id, label: `${c.name}${c.phone ? ` — ${c.phone}` : ''}` })))
    } finally { setLoading(false) }
  }

  useEffect(() => { load() }, [refreshKey])

  return (
    <div className="mb-3">
      <Text className="block !mb-1" type="secondary">{label}</Text>
      <Select
        className="w-full"
        showSearch
        allowClear
        placeholder="Поиск по телефону/имени…"
        value={value}
        onChange={(v) => onChange(typeof v === 'number' ? v : undefined)}
        options={options}
        optionFilterProp="label"
        filterOption={(input, o) => (o?.label as string).toLowerCase().includes(input.toLowerCase())}
        loading={loading}
        notFoundContent={loading ? <Spin size="small" /> : (
          <div className="p-3">
            <Empty description="Не найдено" image={Empty.PRESENTED_IMAGE_SIMPLE} />
          </div>
        )}
        virtual
        status={error ? 'error' : undefined}   // ← только рамка
        aria-invalid={!!error}
      />
    </div>
  )
}


23) .\src\components\RefSelect.tsx
// components/RefSelect.tsx
import { useState, useMemo } from 'react'
import { Select, Typography, Spin } from 'antd'

const { Text } = Typography

export type RefItem = { id: number; name: string }

type Props<T extends RefItem> = {
  label: string
  items: T[]
  value?: number
  onChange: (v: number) => void
  placeholder?: string
  loading?: boolean
  onSearch?: (q: string) => void
  allowClear?: boolean
  disabled?: boolean
  error?: string        // ← принимаем строку, используем как флаг
}

function useDebouncedCallback(cb?: (q: string)=>void, delay = 400) {
  const [t, setT] = useState<number | undefined>()
  return (q: string) => {
    if (!cb) return
    if (t) window.clearTimeout(t)
    const id = window.setTimeout(()=> cb(q), delay)
    setT(id)
  }
}

export default function RefSelect<T extends RefItem>({
  label, items, value, onChange, placeholder = 'Выберите…',
  loading, onSearch, allowClear = true, disabled, error
}: Readonly<Props<T>>) {

  const debouncedSearch = useDebouncedCallback(onSearch, 400)
  const options = useMemo(() => items.map(i => ({ value: i.id, label: i.name })), [items])

  return (
    <div className="mb-4">
      <Text className="block !mb-1" type="secondary">{label}</Text>
      <Select
        className="w-full"
        showSearch
        allowClear={allowClear}
        disabled={disabled}
        placeholder={placeholder}
        value={value}
        onChange={(v) => typeof v === 'number' && onChange(v)}
        options={options}
        filterOption={(input, option) =>
          (option?.label as string)?.toLowerCase().includes(input.toLowerCase())
        }
        onSearch={debouncedSearch}
        loading={loading}
        notFoundContent={loading ? <Spin size="small" /> : null}
        optionFilterProp="label"
        virtual
        status={error ? 'error' : undefined}  // ← только рамка
        aria-invalid={!!error}
      />
    </div>
  )
}


24) .\src\components\SaleGuard.tsx
import { Navigate } from "react-router-dom"

export function SaleGuard({ children }: Readonly<{ children: React.ReactNode }>) {
  const token = localStorage.getItem('tcrm_token')
  if (!token) return <Navigate to="/" replace />
  return children
}

25) .\src\helpers\products.ts
import type { NomenclatureItem } from "@/types/refs"

// helpers/products.ts
export function pickPrice(item: NomenclatureItem, priceTypeId?: number): number {
  if (!item.prices || item.prices.length === 0) return 0
  if (!priceTypeId) {
    const first = item.prices.find(p => typeof p.price === 'number')
    return first?.price ?? 0
  }
  const match = item.prices.find(p => (p).price_type === priceTypeId)
  return match?.price ?? 0
}

export function balanceForWarehouse(item: NomenclatureItem, warehouseName?: string): number | undefined {
  if (!item.balances || !item.balances.length) return undefined
  if (!warehouseName) {
    return item.balances.reduce((s, b) => s + (b.current_amount ?? 0), 0)
  }
  return item.balances
    .filter(b => b.warehouse_name === warehouseName)
    .reduce((s, b) => s + (b.current_amount ?? 0), 0)
}

26) .\src\hooks\useDebounced.ts
// hooks/useDebounced.ts
import { useRef } from 'react'

export function useDebouncedCallback<T extends unknown[]>(
  fn: (...args: T) => void,
  delay = 400
) {
  const timer = useRef<number | undefined>(undefined)
  return (...args: T) => {
    if (timer.current) window.clearTimeout(timer.current)
    timer.current = window.setTimeout(() => fn(...args), delay)
  }
}


27) .\src\screens\SaleScreen.tsx
// src/screens/SaleScreen.tsx
import { useOrganizations, useWarehouses, usePayboxes, usePriceTypes } from '@/api/refs'
import RefSelect from '@/components/RefSelect'
import PhoneSearch from '@/components/PhoneSearch'
import NomenclaturePicker from '@/components/NomenclaturePicker'
import Cart from '@/components/Cart'
import { zodResolver } from '@hookform/resolvers/zod'
import { saleSchema, type SaleFormState } from '@/utils/schema'
import { isAxiosError } from 'axios'
import { useForm, type SubmitErrorHandler, type SubmitHandler } from 'react-hook-form'
import { createSale, extractDocLabel } from '@/api/sales'
import { buildPayload } from '@/utils/payload'
import { useState } from 'react'
import NomenclatureQuickSearch from '@/components/NomenclatureQuickSearch'
import type { NomenclatureItem } from '@/api/products'
import { message } from 'antd'
import { Card, Typography, Divider, Button } from 'antd'
import { round2 } from '@/utils/money'
const { Title, Text } = Typography


export default function SaleScreen() {
    const { data: orgs = [], isLoading: isOrgLoading } = useOrganizations()
    const { data: whs = [], isLoading: isWhLoading } = useWarehouses()
    const { data: payboxes = [], isLoading: isPayboxLoading } = usePayboxes()
    const { data: priceTypes = [], isLoading: isPriceLoading } = usePriceTypes()
    const [messageApi, contextHolder] = message.useMessage()

    const {
        handleSubmit,
        setValue,
        setError,
        trigger,
        watch,
        formState: { isSubmitting, errors },
    } = useForm<SaleFormState>({
        resolver: zodResolver(saleSchema),
        defaultValues: { goods: [], conduct: false },
        mode: 'onChange',
    })

    type LineErr = { price?: string; quantity?: string; discount?: string; sum_discounted?: string }
    // zod сам создаст ошибки на строках при trigger('goods'), мы их подсветим в Cart
    const cartErrors: LineErr[] =
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (Array.isArray(errors.goods) ? errors.goods : [])?.map((e: any) => ({
            price: e?.price?.message,
            quantity: e?.quantity?.message,
            discount: e?.discount?.message,
            sum_discounted: e?.sum_discounted?.message,
        })) ?? []

    const [pickerOpen, setPickerOpen] = useState(false)

    const organization = watch('organization')
    const warehouse = watch('warehouse')
    const priceType = watch('price_type')
    const goods = watch('goods') ?? []
    const formValues = watch()

    const uiTotal = round2((goods ?? []).reduce((s, g) => {
        const price = Number(g.price) || 0
        const qty = Math.max(1, Number(g.quantity) || 1)
        const disc = Number(g.discount ?? 0) || 0
        const sumDisc = Number(g.sum_discounted ?? 0) || 0
        return s + (price * qty - disc - sumDisc)
    }, 0))
    const uiTax = round2(uiTotal * 0.0476)
    const uiNet = round2(uiTotal - uiTax)

    const loading = isOrgLoading || isWhLoading || isPayboxLoading || isPriceLoading
    if (loading) {
        return (
            <div className="flex justify-center items-center h-screen">
                <div className="animate-bounce w-14 h-14 bg-amber-500 rounded-full" />
            </div>
        )
    }

    const onPickNomenclature = (p: NomenclatureItem) => {
        setValue('goods', [
            ...goods,
            { name: p.name, nomenclature: p.id, unit: p.unit, price: 0, discount: 0, sum_discounted: 0, quantity: 1 },
        ], { shouldValidate: true })
        setPickerOpen(false)
    }

    const normalizeErr = (e: unknown) => {
        if (isAxiosError<{ detail?: string }>(e)) return e.response?.data?.detail ?? e.message
        if (e instanceof Error) return e.message
        try { return JSON.stringify(e) } catch { return 'Неизвестная ошибка' }
    }

    // Собираем ВСЕ ошибки, подсвечиваем поля, показываем один message
    const validateAllRequired = async (): Promise<boolean> => {
        const missing: Array<{ path: Parameters<typeof setError>[0]; label: string }> = []

        if (!formValues.organization) missing.push({ path: 'organization', label: 'Организация' })
        if (!formValues.warehouse) missing.push({ path: 'warehouse', label: 'Склад' })
        if (!formValues.paybox) missing.push({ path: 'paybox', label: 'Счёт/касса' })
        if (!formValues.contragent) missing.push({ path: 'contragent', label: 'Контрагент' })
        if (!formValues.price_type) missing.push({ path: 'price_type', label: 'Тип цен' })
        if (!formValues.goods?.length) missing.push({ path: 'goods', label: 'Корзина (добавьте товар)' })

        // проверим строки корзины триггером схемы, чтобы получить field-ошибки
        await trigger('goods');
        console.log('formValues', formValues);

        // руками добавим ошибки на неверные qty/price, чтобы рамка появилась сразу
        (formValues.goods || []).forEach((g, i) => {
            if ((g.quantity ?? 0) <= 0) {
                setError(`goods.${i}.quantity` as Parameters<typeof setError>[0], { type: 'manual', message: 'Количество должно быть > 0' });
            }
            if ((g.price ?? 0) <= 0) {
                console.log(g.price, "g.price")
                setError(`goods.${i}.price` as Parameters<typeof setError>[0], { type: 'manual', message: 'Цена не может быть отрицательной' });
            }
        })

        if (missing.length) {
            missing.forEach(m => setError(m.path, { type: 'manual', message: 'Обязательное поле' }))
            messageApi.error({
                content: (
                    <div>
                        <div>Заполните/исправьте поля:</div>
                        <ul style={{ margin: '6px 0 0 18px' }}>
                            {missing.map(m => <li key={String(m.path)}>{m.label}</li>)}
                        </ul>
                    </div>
                ),
            })
            return false;
        }
        return true;
    }

    // --- Сообщение об ошибках при НЕвалидной форме (рамки уже подсветит RHF) ---
    const onInvalidSubmit: SubmitErrorHandler<SaleFormState> = async () => {
        // Тригерим проверки корзины, чтобы ошибки в строках точно появились
        await trigger('goods');

        // Ручной «обязательность-чек» с установкой ошибок полей
        if (!formValues.price_type) {
            setError('price_type', { type: 'manual', message: 'Обязательное поле' })
        }
        if (!formValues.contragent) {
            setError('contragent', { type: 'manual', message: 'Обязательное поле' })
        }
        if (!formValues.goods?.length) {
            setError('goods', { type: 'manual', message: 'Добавьте хотя бы один товар' });
        }

        // Состыкуем «человеческий» список полей
        const missing: string[] = [];
        if (!formValues.organization) missing.push('Организация');
        if (!formValues.warehouse) missing.push('Склад');
        if (!formValues.paybox) missing.push('Счёт/касса');
        if (!formValues.price_type) missing.push('Тип цен');
        if (!formValues.contragent) missing.push('Контрагент');
        if (!formValues.goods?.length) missing.push('Корзина (добавьте товар)');

        (formValues.goods || []).forEach((g, i) => {
            console.log('goods', g)
            if ((g.quantity ?? 0) <= 0) {
                setError(`goods.${i}.quantity` as Parameters<typeof setError>[0], { type: 'manual', message: 'Количество должно быть > 0' })
            }
            if ((g.price ?? 0) <= 0) {
                setError(`goods.${i}.price` as Parameters<typeof setError>[0], { type: 'manual', message: 'Цена не может быть отрицательной' })
            }
        })
        messageApi.error({
            content: (
                <div>
                    <div>Заполните/исправьте поля:</div>
                    <ul style={{ margin: '6px 0 0 18px' }}>
                        {missing.length
                            ? missing.map((m) => <li key={m}>{m}</li>)
                            : <li>Проверьте значения в корзине</li>}
                    </ul>
                </div>
            ),
        })
    }

    const onSubmitFactory = (conduct: boolean): SubmitHandler<SaleFormState> =>
        async (data) => {
            const ok = await validateAllRequired()
            if (!ok) return
            try {
                const payload = buildPayload({ ...data, conduct })
                console.log('payload', payload)
                const resp = await createSale(payload)
                const label = extractDocLabel(resp)
                message.success(
                    label
                        ? `Документ ${conduct ? 'проведён' : 'создан (черновик)'} № ${label}`
                        : `Документ ${conduct ? 'проведён' : 'создан (черновик)'}`
                )
                setValue('goods', [])
            } catch (e: unknown) {
                message.error(normalizeErr(e) || (conduct ? 'Ошибка при проведении' : 'Ошибка при создании'))
            }
        }

    const submitDraft = handleSubmit(onSubmitFactory(false), onInvalidSubmit)
    const submitConduct = handleSubmit(onSubmitFactory(true), onInvalidSubmit)

    return (
        <div className="min-h-screen flex flex-col w-full">
            {contextHolder}

            <div className="app-container w-full">
                <div className="section-card w-full">
                    <Title level={4} style={{ marginTop: 0, marginBottom: 12 }}>Параметры документа</Title>

                    <RefSelect label="Организация" items={orgs} value={organization}
                        loading={isOrgLoading}
                        onChange={(v) => setValue('organization', v, { shouldValidate: true })}
                        error={errors.organization?.message}
                    />
                    <RefSelect label="Склад" items={whs} value={warehouse}
                        loading={isWhLoading}
                        onChange={(v) => setValue('warehouse', v, { shouldValidate: true })}
                        error={errors.warehouse?.message}
                    />
                    <RefSelect label="Счёт/касса" items={payboxes} value={watch('paybox')}
                        loading={isPayboxLoading}
                        onChange={(v) => setValue('paybox', v, { shouldValidate: true })}
                        error={errors.paybox?.message}
                    />
                    <RefSelect label="Тип цен" items={priceTypes} value={priceType}
                        loading={isPriceLoading}
                        onChange={(v) => setValue('price_type', v, { shouldValidate: true })}
                        error={errors.price_type?.message}
                    />
                    <PhoneSearch
                        value={watch('contragent')}
                        onChange={(id) => setValue('contragent', id, { shouldValidate: true })}
                        error={errors.contragent?.message}
                    />
                </div>

                <div className="section-card">
                    <Title level={4} style={{ marginTop: 0, marginBottom: 12 }}>Номенклатура</Title>
                    <NomenclatureQuickSearch
                        warehouseId={warehouse}
                        onPick={(p) => {
                            setValue('goods', [
                                ...goods,
                                { name: p.name, nomenclature: p.id, unit: p.unit, price: 0, discount: 0, sum_discounted: 0, quantity: 1 },
                            ], { shouldValidate: true })
                            trigger('goods')
                        }}
                        onOpenPicker={() => setPickerOpen(true)}
                        error={!!errors.goods?.message}
                    />
                    <Cart
                        rows={goods}
                        onChange={(rows) => { setValue('goods', rows, { shouldValidate: true }); trigger('goods') }}
                        errors={cartErrors}
                    />
                </div>

                <Card className="section-card">
                    <Title level={5} style={{ marginTop: 0 }}>Итого</Title>
                    <div className="summary-card">
                        <Text className="label">Сумма:</Text>
                        <Text className="value">{uiTotal.toLocaleString('ru-RU', { minimumFractionDigits: 2 })} ₽</Text>

                        <Text className="label">Налог 4,76%:</Text>
                        <Text className="value">{uiTax.toLocaleString('ru-RU', { minimumFractionDigits: 2 })} ₽</Text>

                        <Divider style={{ gridColumn: '1 / span 2', margin: '8px 0' }} />

                        <Text className="label">К оплате (руб.):</Text>
                        <Text className="value">{uiNet.toLocaleString('ru-RU', { minimumFractionDigits: 2 })} ₽</Text>
                    </div>
                </Card>
            </div>

            <div className="action-bar">
                <div className="action-bar__inner">
                    <Button type="primary" size="large" disabled={isSubmitting} onClick={submitDraft}>
                        Создать
                    </Button>
                    <Button size="large" disabled={isSubmitting} onClick={submitConduct}>
                        Создать и провести
                    </Button>
                </div>
            </div>
        </div>
    )
}

28) .\src\screens\TokenScreen.tsx
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { api } from '@/api/client'
import { Card, Typography, Input, Button, Space } from 'antd'

export default function TokenScreen() {
  const [token, setToken] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | undefined>()
  const nav = useNavigate()

  const continueFlow = async () => {
    setError(undefined); setLoading(true)
    try {
      localStorage.setItem('tcrm_token', token.trim())
      await api.get('/api/v1/organizations/')
      nav('/sale')
    } catch (e) {
      setError('Неверный токен или нет доступа')
      console.error(e)
      localStorage.removeItem('tcrm_token')
    } finally { setLoading(false) }
  }

  return (
    <div className="app-container">
      <Card className="section-card" title="Авторизация по токену">
        <Space direction="vertical" style={{ width: '100%' }} size={12}>
          <Input.Password
            placeholder="Вставьте токен"
            value={token}
            onChange={(e) => setToken(e.target.value)}
            size="large"
          />
          <Button
            type="primary"
            block
            size="large"
            loading={loading}
            disabled={!token.trim()}
            onClick={continueFlow}
          >
            Продолжить
          </Button>
          {error && <Typography.Text type="danger">{error}</Typography.Text>}
        </Space>
      </Card>
    </div>
  )
}


29) .\src\types\form.ts
// types/form.ts
export interface LineForm {
  name?: string
  nomenclature: number
  unit: number
  quantity: number
  price: number
  discount?: number
  sum_discounted?: number
}



30) .\src\types\refs.ts
// types/refs.ts
export interface RefItem { id: number; name: string }

export interface ApiItem { count: number; results: RefItem[] }


export interface NomenclatureItem {
  id: number
  name: string
  unit: number
  unit_name?: string | null
  prices: Array<{ price_type?: number; price?: number }>
  balances?: Array<{ warehouse_name: string; current_amount: number }>
}


31) .\src\types\sale.ts
// types/sale.ts
export interface SaleGood {
  price: number;
  quantity: number;
  unit: number;
  discount: number;
  sum_discounted: number;
  nomenclature: number;
}

export interface SalePayloadItem {
  dated: number;
  operation: 'Заказ';
  tax_included: boolean;
  tax_active: boolean;
  goods: SaleGood[];
  settings: { date_next_created: number | null };
  loyality_card_id?: number;
  warehouse: number;
  contragent?: number;
  paybox: number;
  organization: number;
  status: boolean;
  paid_rubles?: number;
  paid_lt?: number;
}

export type SalePayload = SalePayloadItem[];


32) .\src\utils\money.ts
// utils/money.ts
export const round2 = (n: number) => Math.round(n * 100) / 100

33) .\src\utils\payload.ts
// src/utils/payload.ts
import type { SalePayload } from "@/types/sale";
import type { SaleFormState } from "./schema";
import { round2 } from "@/utils/money";

export function buildPayload(form: SaleFormState): SalePayload {
  // Общий итог по корзине: Σ (price * quantity - discount - sum_discounted)
  // без «грязных» NaN и с минимальным qty=1 для безопасности
  const rawTotal = (form.goods ?? []).reduce((sum, g) => {
    const price = Number(g.price) || 0;
    const qty = Math.max(1, Number(g.quantity) || 1);
    const disc = Number(g.discount ?? 0) || 0;
    const sumDisc = Number(g.sum_discounted ?? 0) || 0;
    return sum + (price * qty - disc - sumDisc);
  }, 0);

  const total = round2(rawTotal);             // общий итог
  const taxRate = 0.0476;                     // 4.76%
  const paid_lt = round2(total * taxRate);    // налог 4.76% от итога
  const paid_rubles = round2(total - paid_lt);// итог минус налог

  return [{
    dated: Math.floor(Date.now() / 1000),
    operation: 'Заказ',
    tax_included: true,
    tax_active: true,
    goods: form.goods.map(g => ({
      price: g.price,
      quantity: g.quantity,
      unit: g.unit,
      discount: g.discount ?? 0,
      sum_discounted: g.sum_discounted ?? 0,
      nomenclature: g.nomenclature,
    })),
    settings: { date_next_created: null },
    loyality_card_id: form.loyality_card_id || undefined,
    warehouse: form.warehouse,
    contragent: form.contragent || undefined,
    paybox: form.paybox,
    organization: form.organization,
    status: !!form.conduct,

    // Всегда отправляем вычисленные значения
    paid_rubles,
    paid_lt,
  }]
}


34) .\src\utils\schema.ts
// utils/schema.ts
import { z } from 'zod'

export const saleSchema = z.object({
  paybox: z.number(),            // обязательны схемой
  organization: z.number(),
  warehouse: z.number(),

  // делаем optional на уровне типов формы,
  // а обязательность зададим через superRefine (ниже)
  price_type: z.number().optional(),
  contragent: z.number().optional(),

  loyality_card_id: z.number().optional(),
  goods: z.array(z.object({
    nomenclature: z.number(),
    unit: z.number(),
    quantity: z.number().positive({ message: 'Количество должно быть > 0' }),
    price: z.number().nonnegative({ message: 'Цена не может быть отрицательной' }),
    discount: z.number().min(0).default(0),
    sum_discounted: z.number().min(0).default(0),
    name: z.string().optional(),
  })).min(1, 'Добавьте хотя бы один товар'),
  paid_rubles: z.number().optional(),
  paid_lt: z.number().optional(),
  conduct: z.boolean().default(false),
}).superRefine((data, ctx) => {
  // Требуем заполнения price_type и contragent
  if (data.price_type == null) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      path: ['price_type'],
      message: 'Обязательное поле',
    })
  }
  if (data.contragent == null) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      path: ['contragent'],
      message: 'Обязательное поле',
    })
  }
})

// Используем input-тип — совместим с zodResolver/react-hook-form
export type SaleFormState = z.input<typeof saleSchema>


